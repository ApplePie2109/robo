{"entries":[{"timestamp":1754987196812,"editorVersion":"8.0.15","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":185,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":33,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":200,"length1":41,"diffs":[[1,"        \"README.md\"\n"]]},{"start1":227,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"HCSR04.ts","value":"\n/**\n* Use this file to define custom functions and blocks.\n* Read more at https://makecode.microbit.org/blocks/custom\n*/\n\nenum MyEnum {\n    //% block=\"one\"\n    One,\n    //% block=\"two\"\n    Two\n}\n\n/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace HC_SR04 {\n    /**\n     * TODO: describe your function here\n     * @param n describe parameter here, eg: 5\n     * @param s describe parameter here, eg: \"Hello\"\n     * @param e describe parameter here\n     */\n    //% block\n    export function foo(n: number, s: string, e: MyEnum): void {\n        // Add code here\n    }\n\n    /**\n     * TODO: describe your function here\n     * @param value describe value here, eg: 5\n     */\n    //% block\n    export function fib(value: number): number {\n        return value <= 1 ? value : fib(value -1) + fib(value - 2);\n    }\n}\n"}]},{"timestamp":1754987893099,"editorVersion":"8.0.15","changes":[{"type":"edited","filename":"HCSR04.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"\n"]]},{"start1":5,"length1":273,"diffs":[[1,"* Use this file to define custom functions and blocks.\n* Read more at https://makecode.microbit.org/blocks/custom\n*/\n\nenum MyEnum {\n    //% block=\"one\"\n    One,\n    //% block=\"two\"\n    Two\n}\n\n/**\n * Custom blocks\n"]]},{"start1":222,"length1":84,"diffs":[[1,"//% weight=100 color=#0fbc11 icon=\"\"\n"]]},{"start1":288,"length1":27,"diffs":[[1,"     * TODO: describe your function here\n     * @param n describe parameter here, eg: 5\n     * @param s describe parameter here, eg: \"Hello\"\n     * @param e describe parameter here\n"]]},{"start1":477,"length1":176,"diffs":[[1,"    //% block\n    export function foo(n: number, s: string, e: MyEnum): void {\n        // Add code here\n"]]},{"start1":596,"length1":424,"diffs":[[1,"     * TODO: describe your function here\n     * @param value describe value here, eg: 5\n"]]},{"start1":692,"length1":1363,"diffs":[[1,"    //% block\n    export function fib(value: number): number {\n        return value <= 1 ? value : fib(value -1) + fib(value - 2);\n"]]},{"start1":829,"length1":1718,"diffs":[[1,""]]}]}]},{"timestamp":1754987896716,"editorVersion":"8.0.15","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":221,"length1":72,"diffs":[[1,"        \"HCSR04.ts\"\n"]]}]},{"type":"added","filename":"hc_sr04_multi..ts","value":"//% weight=100 color=#0fbc11 icon=\"\\uf2a2\" block=\"HC-SR04 Multi\"\nnamespace HC_SR04_Multi {\n    let trigPin: DigitalPin;\n    let echoPins: DigitalPin[] = [];\n\n    /**\n     * Khởi tạo nhiều cảm biến HC-SR04 với 1 TRIG chung.\n     * @param trig chân TRIG dùng chung, ví dụ DigitalPin.P1\n     * @param echos mảng chân ECHO, ví dụ [DigitalPin.P2, DigitalPin.P3]\n     */\n    //% blockId=\"hc_sr04_multi_init\"\n    //% block=\"init HC-SR04 with trig %trig and echo pins %echos\"\n    export function init(trig: DigitalPin, echos: DigitalPin[]): void {\n        trigPin = trig;\n        echoPins = echos;\n        pins.setPull(trigPin, PinPullMode.PullNone);\n        pins.digitalWritePin(trigPin, 0);\n        for (let e of echoPins) {\n            pins.setPull(e, PinPullMode.PullNone);\n        }\n    }\n\n    /**\n     * Đo khoảng cách từ cảm biến có chỉ số index (0-based)\n     * @param index vị trí cảm biến trong mảng ECHO\n     * @param maxDistanceCm khoảng cách tối đa cần đo, mặc định 400 cm\n     */\n    //% blockId=\"hc_sr04_multi_distance\"\n    //% block=\"distance from sensor %index || max %maxDistanceCm|cm\"\n    export function distance(index: number, maxDistanceCm: number = 400): number {\n        if (index < 0 || index >= echoPins.length) return -1;\n\n        // Đưa TRIG về LOW ít nhất 2 µs\n        pins.digitalWritePin(trigPin, 0);\n        control.waitMicros(2);\n\n        // Gửi xung TRIG 10 µs\n        pins.digitalWritePin(trigPin, 1);\n        control.waitMicros(10);\n        pins.digitalWritePin(trigPin, 0);\n\n        // Đo độ rộng xung HIGH trên ECHO\n        let pulse = pins.pulseIn(echoPins[index], PulseValue.High, maxDistanceCm * 58);\n        if (pulse <= 0) return -1; // timeout\n        return Math.idiv(pulse, 58); // cm\n    }\n}\n"},{"type":"added","filename":"tcrt5000.ts","value":"//% weight=100 color=#ff6600 icon=\"\\uf06e\" block=\"TCRT5000\"\nnamespace TCRT5000 {\n    /**\n     * Đọc giá trị analog từ cảm biến TCRT5000\n     * @param pin chân analog nối với OUT của TCRT5000, ví dụ AnalogPin.P0\n     * @returns giá trị ADC (0-1023)\n     */\n    //% blockId=\"tcrt5000_read_analog\"\n    //% block=\"analog value from TCRT5000 at pin %pin\"\n    export function readAnalog(pin: AnalogPin): number {\n        return pins.analogReadPin(pin);\n    }\n\n    /**\n     * Đọc trạng thái digital (nếu module có LM393 comparator)\n     * @param pin chân digital nối với OUT của TCRT5000, ví dụ DigitalPin.P0\n     * @returns true nếu phát hiện phản xạ mạnh (nền sáng), false nếu phản xạ yếu (nền tối)\n     */\n    //% blockId=\"tcrt5000_read_digital\"\n    //% block=\"digital state from TCRT5000 at pin %pin\"\n    export function readDigital(pin: DigitalPin): boolean {\n        return pins.digitalReadPin(pin) == 1;\n    }\n\n    /**\n     * Kiểm tra có phát hiện vật phản xạ gần hay không\n     * @param pin chân analog nối OUT\n     * @param threshold ngưỡng so sánh (0-1023), ví dụ 500\n     * @returns true nếu giá trị lớn hơn ngưỡng\n     */\n    //% blockId=\"tcrt5000_detect\"\n    //% block=\"detected object on pin %pin with threshold %threshold\"\n    export function isDetected(pin: AnalogPin, threshold: number = 500): boolean {\n        return pins.analogReadPin(pin) > threshold;\n    }\n}\n"}]},{"timestamp":1754988408598,"editorVersion":"8.0.15","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":133,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":271,"length1":67,"diffs":[[1,"        \"tcrt5000.ts\"\n"]]}]},{"type":"added","filename":"irm_3636t.ts","value":"//% weight=100 color=#0099ff icon=\"\\uf1eb\" block=\"IRM-3636T\"\nnamespace IRM_3636T {\n    let irPin: DigitalPin;\n    let callback: (code: number) => void;\n\n    /**\n     * Khởi tạo IRM-3636T trên chân digital\n     * @param pin chân OUT nối vào micro:bit, ví dụ DigitalPin.P0\n     */\n    //% blockId=\"irm_3636t_init\"\n    //% block=\"init IRM-3636T at pin %pin\"\n    export function init(pin: DigitalPin): void {\n        irPin = pin;\n        control.inBackground(function () {\n            while (true) {\n                let code = readNEC()\n                if (code != -1 && callback) {\n                    callback(code)\n                }\n            }\n        });\n    }\n\n    /**\n     * Gọi hàm khi nhận được mã IR (NEC)\n     * @param cb hàm callback, trả về mã nguyên 32-bit\n     */\n    //% blockId=\"irm_3636t_on_receive\"\n    //% block=\"on IR code received\"\n    export function onCodeReceived(cb: (code: number) => void): void {\n        callback = cb;\n    }\n\n    // Đọc tín hiệu NEC từ cảm biến IR\n    function readNEC(): number {\n        // Chờ leader pulse ~9ms LOW\n        if (pins.pulseIn(irPin, PulseValue.Low, 100000) < 8000) return -1;\n        // Chờ leader space ~4.5ms HIGH\n        if (pins.pulseIn(irPin, PulseValue.High, 100000) < 4000) return -1;\n\n        let data = 0;\n        for (let i = 0; i < 32; i++) {\n            let lowTime = pins.pulseIn(irPin, PulseValue.Low, 100000);\n            let highTime = pins.pulseIn(irPin, PulseValue.High, 100000);\n            if (highTime > 1000) {\n                // Bit '1'\n                data = (data << 1) | 1;\n            } else {\n                // Bit '0'\n                data = (data << 1);\n            }\n        }\n        return data;\n    }\n}\n"},{"type":"added","filename":"hs0147.ts","value":"//% weight=100 icon=\"\\uf185\" block=\"HS0147 Light\"\nnamespace HS0147 {\n    /**\n     * Đọc giá trị ánh sáng từ cảm biến HS0147 (0–1023)\n     * @param pin chân analog nối với OUT của HS0147, ví dụ AnalogPin.P1\n     */\n    //% blockId=\"hs0147_read\"\n    //% block=\"light value from HS0147 at pin %pin\"\n    export function readLight(pin: AnalogPin): number {\n        return pins.analogReadPin(pin);\n    }\n\n    /**\n     * Kiểm tra ánh sáng vượt ngưỡng\n     * @param pin chân analog OUT\n     * @param threshold ngưỡng (0–1023)\n     * @returns true nếu ánh sáng mạnh hơn ngưỡng\n     */\n    //% blockId=\"hs0147_is_bright\"\n    //% block=\"is bright on pin %pin with threshold %threshold\"\n    export function isBright(pin: AnalogPin, threshold: number = 512): boolean {\n        return pins.analogReadPin(pin) > threshold;\n    }\n}\n"}]},{"timestamp":1754988979391,"editorVersion":"8.0.15","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":84,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"device_forever\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":345,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1754987196811,"editorVersion":"8.0.15","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"robo\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1754989136708,"editorVersion":"8.0.15","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"device_forever\" x=\"0\" y=\"0\"></block></xml>","main.ts":"basic.forever(function () {\n\t\n})\n","README.md":"","HCSR04.ts":"/**\n * HC-SR04 ultrasonic distance sensor for micro:bit (MakeCode)\n * Works with 3-wire trigger/echo or 4-wire modules.\n * NOTE: micro:bit GPIOs are 3.3V tolerant. The HC‑SR04 ECHO pin outputs 5V.\n *       Use a voltage divider (e.g., 1k + 2k) or a safe level shifter on ECHO.\n */\n//% weight=100 color=#0fbc11 icon=\"\\uf2a2\" block=\"HC‑SR04\"\n//% groups='[\"Measure\"]'\nnamespace HC_SR04 {\n    /**\n     * Units for distance.\n     */\n    export enum Unit {\n        //% block=\"cm\"\n        Centimeters = 0,\n        //% block=\"inch\"\n        Inches = 1,\n        //% block=\"µs (echo high)\"\n        MicroSeconds = 2\n    }\n\n    /**\n     * Measure distance once.\n     * The function triggers the sensor, waits for the echo pulse and converts it.\n     * @param trig the digital pin connected to TRIG, eg: DigitalPin.P1\n     * @param echo the digital pin connected to ECHO (level-shifted!), eg: DigitalPin.P2\n     * @param unit the desired output unit, eg: HC_SR04.Unit.Centimeters\n     * @param maxDistanceCm cap measurement to reduce blocking time, eg: 400\n     */\n    //% blockId=\"hc_sr04_distance\"\n    //% block=\"distance (HC‑SR04) trig %trig echo %echo unit %unit||max %maxDistanceCm|cm\"\n    //% trig.defl=DigitalPin.P1 echo.defl=DigitalPin.P2 unit.defl=HC_SR04.Unit.Centimeters maxDistanceCm.defl=400\n    //% weight=100 help=github:distance\n    //% group=\"Measure\"\n    export function distance(trig: DigitalPin, echo: DigitalPin, unit: Unit = Unit.Centimeters, maxDistanceCm: number = 400): number {\n        // Ensure pins are in a known state\n        pins.setPull(echo, PinPullMode.PullNone);\n        pins.digitalWritePin(trig, 0);\n        control.waitMicros(2);\n\n        // 10 µs trigger pulse\n        pins.digitalWritePin(trig, 1);\n        control.waitMicros(10);\n        pins.digitalWritePin(trig, 0);\n\n        // Wait for echo: pulseIn returns the duration ECHO stayed high (µs),\n        // or 0 on timeout. Use ~58 µs per centimeter (round trip).\n        const maxEchoUs = maxDistanceCm * 58; // typical datasheet conversion\n        const pulse = pins.pulseIn(echo, PulseValue.High, maxEchoUs);\n\n        if (pulse <= 0) {\n            // Timeout or invalid reading\n            return -1;\n        }\n\n        switch (unit) {\n            case Unit.MicroSeconds: return pulse;\n            case Unit.Inches: return Math.idiv(pulse, 148); // ~148 µs per inch\n            default: return Math.idiv(pulse, 58); // cm\n        }\n    }\n\n    /**\n     * Measure distance multiple times and return the median (robust against outliers).\n     * @param trig TRIG pin, eg: DigitalPin.P1\n     * @param echo ECHO pin (level-shifted), eg: DigitalPin.P2\n     * @param samples number of samples to take (3–9 recommended), eg: 5\n     * @param spacingMs delay between samples to let echoes dissipate, eg: 50\n     * @param unit output unit, eg: HC_SR04.Unit.Centimeters\n     */\n    //% blockId=\"hc_sr04_distance_median\"\n    //% block=\"distance median (HC‑SR04) trig %trig echo %echo samples %samples spacing %spacingMs|ms unit %unit\"\n    //% trig.defl=DigitalPin.P1 echo.defl=DigitalPin.P2 samples.min=1 samples.max=9 samples.defl=5 spacingMs.defl=50 unit.defl=HC_SR04.Unit.Centimeters\n    //% weight=90\n    //% group=\"Measure\"\n    export function distanceMedian(\n        trig: DigitalPin,\n        echo: DigitalPin,\n        samples: number = 5,\n        spacingMs: number = 50,\n        unit: Unit = Unit.Centimeters\n    ): number {\n        if (samples <= 1) {\n            return distance(trig, echo, unit);\n        }\n        const arr: number[] = [];\n        for (let i = 0; i < samples; i++) {\n            const d = distance(trig, echo, Unit.MicroSeconds);\n            if (d > 0) arr.push(d);\n            basic.pause(spacingMs);\n        }\n        if (arr.length == 0) return -1;\n\n        // Sort and take median\n        arr.sort((a, b) => a - b);\n        const mid = arr.length >> 1;\n        const us = (arr.length % 2 == 0) ? Math.idiv(arr[mid - 1] + arr[mid], 2) : arr[mid];\n\n        switch (unit) {\n            case Unit.MicroSeconds: return us;\n            case Unit.Inches: return Math.idiv(us, 148);\n            default: return Math.idiv(us, 58);\n        }\n    }\n}\n","hc_sr04_multi..ts":"//% weight=100 color=#0fbc11 icon=\"\\uf2a2\" block=\"HC-SR04 Multi\"\nnamespace HC_SR04_Multi {\n    let trigPin: DigitalPin;\n    let echoPins: DigitalPin[] = [];\n\n    /**\n     * Khởi tạo nhiều cảm biến HC-SR04 với 1 TRIG chung.\n     * @param trig chân TRIG dùng chung, ví dụ DigitalPin.P1\n     * @param echos mảng chân ECHO, ví dụ [DigitalPin.P2, DigitalPin.P3]\n     */\n    //% blockId=\"hc_sr04_multi_init\"\n    //% block=\"init HC-SR04 with trig %trig and echo pins %echos\"\n    export function init(trig: DigitalPin, echos: DigitalPin[]): void {\n        trigPin = trig;\n        echoPins = echos;\n        pins.setPull(trigPin, PinPullMode.PullNone);\n        pins.digitalWritePin(trigPin, 0);\n        for (let e of echoPins) {\n            pins.setPull(e, PinPullMode.PullNone);\n        }\n    }\n\n    /**\n     * Đo khoảng cách từ cảm biến có chỉ số index (0-based)\n     * @param index vị trí cảm biến trong mảng ECHO\n     * @param maxDistanceCm khoảng cách tối đa cần đo, mặc định 400 cm\n     */\n    //% blockId=\"hc_sr04_multi_distance\"\n    //% block=\"distance from sensor %index || max %maxDistanceCm|cm\"\n    export function distance(index: number, maxDistanceCm: number = 400): number {\n        if (index < 0 || index >= echoPins.length) return -1;\n\n        // Đưa TRIG về LOW ít nhất 2 µs\n        pins.digitalWritePin(trigPin, 0);\n        control.waitMicros(2);\n\n        // Gửi xung TRIG 10 µs\n        pins.digitalWritePin(trigPin, 1);\n        control.waitMicros(10);\n        pins.digitalWritePin(trigPin, 0);\n\n        // Đo độ rộng xung HIGH trên ECHO\n        let pulse = pins.pulseIn(echoPins[index], PulseValue.High, maxDistanceCm * 58);\n        if (pulse <= 0) return -1; // timeout\n        return Math.idiv(pulse, 58); // cm\n    }\n}\n","tcrt5000.ts":"//% weight=100 color=#ff6600 icon=\"\\uf06e\" block=\"TCRT5000\"\nnamespace TCRT5000 {\n    /**\n     * Đọc giá trị analog từ cảm biến TCRT5000\n     * @param pin chân analog nối với OUT của TCRT5000, ví dụ AnalogPin.P0\n     * @returns giá trị ADC (0-1023)\n     */\n    //% blockId=\"tcrt5000_read_analog\"\n    //% block=\"analog value from TCRT5000 at pin %pin\"\n    export function readAnalog(pin: AnalogPin): number {\n        return pins.analogReadPin(pin);\n    }\n\n    /**\n     * Đọc trạng thái digital (nếu module có LM393 comparator)\n     * @param pin chân digital nối với OUT của TCRT5000, ví dụ DigitalPin.P0\n     * @returns true nếu phát hiện phản xạ mạnh (nền sáng), false nếu phản xạ yếu (nền tối)\n     */\n    //% blockId=\"tcrt5000_read_digital\"\n    //% block=\"digital state from TCRT5000 at pin %pin\"\n    export function readDigital(pin: DigitalPin): boolean {\n        return pins.digitalReadPin(pin) == 1;\n    }\n\n    /**\n     * Kiểm tra có phát hiện vật phản xạ gần hay không\n     * @param pin chân analog nối OUT\n     * @param threshold ngưỡng so sánh (0-1023), ví dụ 500\n     * @returns true nếu giá trị lớn hơn ngưỡng\n     */\n    //% blockId=\"tcrt5000_detect\"\n    //% block=\"detected object on pin %pin with threshold %threshold\"\n    export function isDetected(pin: AnalogPin, threshold: number = 500): boolean {\n        return pins.analogReadPin(pin) > threshold;\n    }\n}\n","irm_3636t.ts":"//% weight=100 color=#0099ff icon=\"\\uf1eb\" block=\"IRM-3636T\"\nnamespace IRM_3636T {\n    let irPin: DigitalPin;\n    let callback: (code: number) => void;\n\n    /**\n     * Khởi tạo IRM-3636T trên chân digital\n     * @param pin chân OUT nối vào micro:bit, ví dụ DigitalPin.P0\n     */\n    //% blockId=\"irm_3636t_init\"\n    //% block=\"init IRM-3636T at pin %pin\"\n    export function init(pin: DigitalPin): void {\n        irPin = pin;\n        control.inBackground(function () {\n            while (true) {\n                let code = readNEC()\n                if (code != -1 && callback) {\n                    callback(code)\n                }\n            }\n        });\n    }\n\n    /**\n     * Gọi hàm khi nhận được mã IR (NEC)\n     * @param cb hàm callback, trả về mã nguyên 32-bit\n     */\n    //% blockId=\"irm_3636t_on_receive\"\n    //% block=\"on IR code received\"\n    export function onCodeReceived(cb: (code: number) => void): void {\n        callback = cb;\n    }\n\n    // Đọc tín hiệu NEC từ cảm biến IR\n    function readNEC(): number {\n        // Chờ leader pulse ~9ms LOW\n        if (pins.pulseIn(irPin, PulseValue.Low, 100000) < 8000) return -1;\n        // Chờ leader space ~4.5ms HIGH\n        if (pins.pulseIn(irPin, PulseValue.High, 100000) < 4000) return -1;\n\n        let data = 0;\n        for (let i = 0; i < 32; i++) {\n            let lowTime = pins.pulseIn(irPin, PulseValue.Low, 100000);\n            let highTime = pins.pulseIn(irPin, PulseValue.High, 100000);\n            if (highTime > 1000) {\n                // Bit '1'\n                data = (data << 1) | 1;\n            } else {\n                // Bit '0'\n                data = (data << 1);\n            }\n        }\n        return data;\n    }\n}\n","hs0147.ts":"//% weight=100 icon=\"\\uf185\" block=\"HS0147 Light\"\nnamespace HS0147 {\n    /**\n     * Đọc giá trị ánh sáng từ cảm biến HS0147 (0–1023)\n     * @param pin chân analog nối với OUT của HS0147, ví dụ AnalogPin.P1\n     */\n    //% blockId=\"hs0147_read\"\n    //% block=\"light value from HS0147 at pin %pin\"\n    export function readLight(pin: AnalogPin): number {\n        return pins.analogReadPin(pin);\n    }\n\n    /**\n     * Kiểm tra ánh sáng vượt ngưỡng\n     * @param pin chân analog OUT\n     * @param threshold ngưỡng (0–1023)\n     * @returns true nếu ánh sáng mạnh hơn ngưỡng\n     */\n    //% blockId=\"hs0147_is_bright\"\n    //% block=\"is bright on pin %pin with threshold %threshold\"\n    export function isBright(pin: AnalogPin, threshold: number = 512): boolean {\n        return pins.analogReadPin(pin) > threshold;\n    }\n}\n","pxt.json":"{\n    \"name\": \"robo\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"HCSR04.ts\",\n        \"hc_sr04_multi..ts\",\n        \"tcrt5000.ts\",\n        \"irm_3636t.ts\",\n        \"hs0147.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1754989136712}